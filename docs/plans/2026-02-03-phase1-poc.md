# Phase 1: Proof-of-Concept Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Establish the core data flow (PTY ↔ wsh ↔ API clients) with a working transparent shell wrapper.

**Architecture:** wsh spawns a PTY running the user's shell, puts the local terminal in raw mode for transparent passthrough, and runs an Axum server exposing WebSocket (`/ws/raw`) and HTTP (`POST /input`, `GET /health`) endpoints. All input sources feed an mpsc channel to a single PTY writer task; PTY output broadcasts to stdout and all WebSocket clients.

**Tech Stack:** Rust, Tokio, Axum, portable-pty, crossterm

**Success Criteria:**
- `curl -X POST -d 'ls' localhost:8080/input` sends keystrokes to the shell
- `websocat ws://localhost:8080/ws/raw` streams terminal output in real-time
- Local terminal works normally (transparent passthrough)

---

## Task 1: Project Scaffolding

**Files:**
- Create: `Cargo.toml`
- Create: `src/main.rs`

**Step 1: Create Cargo.toml with dependencies**

```toml
[package]
name = "wsh"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }
axum = { version = "0.7", features = ["ws"] }
tower-http = { version = "0.5", features = ["trace"] }
portable-pty = "0.8"
crossterm = "0.27"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
futures = "0.3"
bytes = "1"
```

**Step 2: Create minimal main.rs**

```rust
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "wsh=debug,tower_http=debug".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("wsh starting");
}
```

**Step 3: Verify it compiles and runs**

Run: `nix develop -c sh -c "cargo run"`
Expected: Logs "wsh starting" and exits cleanly

**Step 4: Commit**

```bash
git add Cargo.toml src/main.rs
git commit -m "feat: initial project scaffolding with dependencies"
```

---

## Task 2: PTY Module - Spawn Shell

**Files:**
- Create: `src/pty.rs`
- Modify: `src/main.rs`

**Step 1: Create pty.rs with shell spawning**

```rust
use portable_pty::{native_pty_system, CommandBuilder, PtyPair, PtySize};
use std::io::{Read, Write};

pub struct Pty {
    pair: PtyPair,
    child: Box<dyn portable_pty::Child + Send + Sync>,
}

impl Pty {
    pub fn spawn() -> anyhow::Result<Self> {
        let pty_system = native_pty_system();

        // Get terminal size from environment or use defaults
        let size = PtySize {
            rows: std::env::var("LINES")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or(24),
            cols: std::env::var("COLUMNS")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or(80),
            pixel_width: 0,
            pixel_height: 0,
        };

        let pair = pty_system.openpty(size)?;

        // Use $SHELL or fall back to /bin/sh
        let shell = std::env::var("SHELL").unwrap_or_else(|_| "/bin/sh".to_string());
        let mut cmd = CommandBuilder::new(&shell);
        cmd.env("TERM", std::env::var("TERM").unwrap_or_else(|_| "xterm-256color".to_string()));

        let child = pair.slave.spawn_command(cmd)?;

        Ok(Self { pair, child })
    }

    pub fn take_reader(&self) -> anyhow::Result<Box<dyn Read + Send>> {
        Ok(self.pair.master.try_clone_reader()?)
    }

    pub fn take_writer(&self) -> anyhow::Result<Box<dyn Write + Send>> {
        Ok(self.pair.master.take_writer()?)
    }

    pub fn resize(&self, rows: u16, cols: u16) -> anyhow::Result<()> {
        self.pair.master.resize(PtySize {
            rows,
            cols,
            pixel_width: 0,
            pixel_height: 0,
        })?;
        Ok(())
    }

    pub fn wait(&mut self) -> anyhow::Result<portable_pty::ExitStatus> {
        Ok(self.child.wait()?)
    }
}
```

**Step 2: Add anyhow dependency to Cargo.toml**

Add to `[dependencies]`:
```toml
anyhow = "1"
```

**Step 3: Update main.rs to use pty module**

```rust
mod pty;

use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "wsh=debug,tower_http=debug".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("wsh starting");

    let mut pty = pty::Pty::spawn()?;
    tracing::info!("PTY spawned");

    let status = pty.wait()?;
    tracing::info!(?status, "shell exited");

    Ok(())
}
```

**Step 4: Verify shell spawns and exits**

Run: `nix develop -c sh -c "echo 'exit' | cargo run 2>&1"`
Expected: Logs show PTY spawned and shell exited

**Step 5: Commit**

```bash
git add Cargo.toml src/pty.rs src/main.rs
git commit -m "feat: add PTY module that spawns user's shell"
```

---

## Task 3: Raw Mode Terminal Guard

**Files:**
- Create: `src/terminal.rs`
- Modify: `src/main.rs`

**Step 1: Create terminal.rs with raw mode guard**

```rust
use crossterm::terminal::{disable_raw_mode, enable_raw_mode};

pub struct RawModeGuard {
    _private: (),
}

impl RawModeGuard {
    pub fn new() -> anyhow::Result<Self> {
        enable_raw_mode()?;
        Ok(Self { _private: () })
    }
}

impl Drop for RawModeGuard {
    fn drop(&mut self) {
        let _ = disable_raw_mode();
    }
}
```

**Step 2: Update main.rs to enable raw mode**

```rust
mod pty;
mod terminal;

use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "wsh=debug,tower_http=debug".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("wsh starting");

    // Enable raw mode - guard restores on drop
    let _raw_guard = terminal::RawModeGuard::new()?;

    let mut pty = pty::Pty::spawn()?;
    tracing::info!("PTY spawned");

    let status = pty.wait()?;
    tracing::info!(?status, "shell exited");

    Ok(())
}
```

**Step 3: Verify raw mode enables and restores**

Run: `nix develop -c sh -c "cargo build"` (just build, don't run interactively yet)
Expected: Compiles successfully

**Step 4: Commit**

```bash
git add src/terminal.rs src/main.rs
git commit -m "feat: add raw mode terminal guard with RAII cleanup"
```

---

## Task 4: PTY Reader Task with Broadcast

**Files:**
- Create: `src/broker.rs`
- Modify: `src/main.rs`

**Step 1: Create broker.rs for output fanout**

```rust
use bytes::Bytes;
use tokio::sync::broadcast;

pub const BROADCAST_CAPACITY: usize = 64;

#[derive(Clone)]
pub struct Broker {
    tx: broadcast::Sender<Bytes>,
}

impl Broker {
    pub fn new() -> Self {
        let (tx, _) = broadcast::channel(BROADCAST_CAPACITY);
        Self { tx }
    }

    pub fn publish(&self, data: Bytes) {
        // Ignore error - means no receivers
        let _ = self.tx.send(data);
    }

    pub fn subscribe(&self) -> broadcast::Receiver<Bytes> {
        self.tx.subscribe()
    }
}
```

**Step 2: Update main.rs with PTY reader task**

```rust
mod broker;
mod pty;
mod terminal;

use bytes::Bytes;
use std::io::{Read, Write};
use tokio::sync::mpsc;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "wsh=debug,tower_http=debug".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("wsh starting");

    let _raw_guard = terminal::RawModeGuard::new()?;

    let pty = pty::Pty::spawn()?;
    let mut pty_reader = pty.take_reader()?;

    let broker = broker::Broker::new();
    let broker_clone = broker.clone();

    // PTY reader task: read from PTY, write to stdout, broadcast
    let pty_reader_handle = tokio::task::spawn_blocking(move || {
        let mut stdout = std::io::stdout();
        let mut buf = [0u8; 4096];

        loop {
            match pty_reader.read(&mut buf) {
                Ok(0) => {
                    tracing::debug!("PTY reader: EOF");
                    break;
                }
                Ok(n) => {
                    let data = Bytes::copy_from_slice(&buf[..n]);
                    // Write to stdout
                    let _ = stdout.write_all(&data);
                    let _ = stdout.flush();
                    // Broadcast to subscribers
                    broker_clone.publish(data);
                }
                Err(e) => {
                    tracing::error!(?e, "PTY read error");
                    break;
                }
            }
        }
    });

    pty_reader_handle.await?;
    tracing::info!("PTY reader finished");

    Ok(())
}
```

**Step 3: Verify PTY output appears on stdout**

Run manually in terminal: `nix develop -c sh -c "cargo run"`
Expected: You should see a shell prompt (though input won't work yet). Type `exit` blindly and press Enter to exit.

**Step 4: Commit**

```bash
git add src/broker.rs src/main.rs
git commit -m "feat: add broker and PTY reader task with stdout passthrough"
```

---

## Task 5: Local Stdin Reader Task

**Files:**
- Modify: `src/main.rs`

**Step 1: Add stdin reader and PTY writer tasks**

Replace main.rs with:

```rust
mod broker;
mod pty;
mod terminal;

use bytes::Bytes;
use std::io::{Read, Write};
use tokio::sync::mpsc;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "wsh=debug,tower_http=debug".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("wsh starting");

    let _raw_guard = terminal::RawModeGuard::new()?;

    let pty = pty::Pty::spawn()?;
    let mut pty_reader = pty.take_reader()?;
    let mut pty_writer = pty.take_writer()?;

    let broker = broker::Broker::new();
    let broker_clone = broker.clone();

    // Channel for input from all sources -> PTY writer
    let (input_tx, mut input_rx) = mpsc::channel::<Bytes>(64);

    // PTY reader task: read from PTY, write to stdout, broadcast
    let pty_reader_handle = tokio::task::spawn_blocking(move || {
        let mut stdout = std::io::stdout();
        let mut buf = [0u8; 4096];

        loop {
            match pty_reader.read(&mut buf) {
                Ok(0) => {
                    tracing::debug!("PTY reader: EOF");
                    break;
                }
                Ok(n) => {
                    let data = Bytes::copy_from_slice(&buf[..n]);
                    let _ = stdout.write_all(&data);
                    let _ = stdout.flush();
                    broker_clone.publish(data);
                }
                Err(e) => {
                    tracing::error!(?e, "PTY read error");
                    break;
                }
            }
        }
    });

    // PTY writer task: receive from channel, write to PTY
    let pty_writer_handle = tokio::task::spawn_blocking(move || {
        while let Some(data) = input_rx.blocking_recv() {
            if let Err(e) = pty_writer.write_all(&data) {
                tracing::error!(?e, "PTY write error");
                break;
            }
            let _ = pty_writer.flush();
        }
        tracing::debug!("PTY writer: channel closed");
    });

    // Stdin reader task: read from stdin, send to PTY writer channel
    let stdin_tx = input_tx.clone();
    let stdin_handle = tokio::task::spawn_blocking(move || {
        let mut stdin = std::io::stdin();
        let mut buf = [0u8; 1024];

        loop {
            match stdin.read(&mut buf) {
                Ok(0) => {
                    tracing::debug!("stdin: EOF");
                    break;
                }
                Ok(n) => {
                    let data = Bytes::copy_from_slice(&buf[..n]);
                    if stdin_tx.blocking_send(data).is_err() {
                        break;
                    }
                }
                Err(e) => {
                    tracing::error!(?e, "stdin read error");
                    break;
                }
            }
        }
    });

    // Wait for PTY reader to finish (shell exited)
    pty_reader_handle.await?;

    // Drop input_tx to signal PTY writer to stop
    drop(input_tx);
    let _ = pty_writer_handle.await;

    // stdin_handle will exit when stdin closes or we exit
    stdin_handle.abort();

    tracing::info!("wsh exiting");
    Ok(())
}
```

**Step 2: Test interactive shell**

Run: `nix develop -c sh -c "cargo run"`
Expected: Full interactive shell - you can type commands, see output, use Ctrl+C, type `exit` to quit cleanly.

**Step 3: Commit**

```bash
git add src/main.rs
git commit -m "feat: add stdin reader and PTY writer tasks for full interactive shell"
```

---

## Task 6: Axum Server Skeleton

**Files:**
- Create: `src/api.rs`
- Modify: `src/main.rs`

**Step 1: Create api.rs with health endpoint**

```rust
use axum::{routing::get, Json, Router};
use serde::Serialize;

#[derive(Serialize)]
struct HealthResponse {
    status: &'static str,
}

async fn health() -> Json<HealthResponse> {
    Json(HealthResponse { status: "ok" })
}

pub fn router() -> Router {
    Router::new().route("/health", get(health))
}
```

**Step 2: Add serde dependency to Cargo.toml**

Add to `[dependencies]`:
```toml
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

**Step 3: Update main.rs to spawn Axum server**

Add after the stdin_handle setup, before waiting on pty_reader_handle:

```rust
mod api;
mod broker;
mod pty;
mod terminal;

use bytes::Bytes;
use std::io::{Read, Write};
use std::net::SocketAddr;
use tokio::sync::mpsc;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "wsh=debug,tower_http=debug".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("wsh starting");

    let _raw_guard = terminal::RawModeGuard::new()?;

    let pty = pty::Pty::spawn()?;
    let mut pty_reader = pty.take_reader()?;
    let mut pty_writer = pty.take_writer()?;

    let broker = broker::Broker::new();
    let broker_clone = broker.clone();

    let (input_tx, mut input_rx) = mpsc::channel::<Bytes>(64);

    // PTY reader task
    let pty_reader_handle = tokio::task::spawn_blocking(move || {
        let mut stdout = std::io::stdout();
        let mut buf = [0u8; 4096];

        loop {
            match pty_reader.read(&mut buf) {
                Ok(0) => {
                    tracing::debug!("PTY reader: EOF");
                    break;
                }
                Ok(n) => {
                    let data = Bytes::copy_from_slice(&buf[..n]);
                    let _ = stdout.write_all(&data);
                    let _ = stdout.flush();
                    broker_clone.publish(data);
                }
                Err(e) => {
                    tracing::error!(?e, "PTY read error");
                    break;
                }
            }
        }
    });

    // PTY writer task
    let pty_writer_handle = tokio::task::spawn_blocking(move || {
        while let Some(data) = input_rx.blocking_recv() {
            if let Err(e) = pty_writer.write_all(&data) {
                tracing::error!(?e, "PTY write error");
                break;
            }
            let _ = pty_writer.flush();
        }
        tracing::debug!("PTY writer: channel closed");
    });

    // Stdin reader task
    let stdin_tx = input_tx.clone();
    let stdin_handle = tokio::task::spawn_blocking(move || {
        let mut stdin = std::io::stdin();
        let mut buf = [0u8; 1024];

        loop {
            match stdin.read(&mut buf) {
                Ok(0) => {
                    tracing::debug!("stdin: EOF");
                    break;
                }
                Ok(n) => {
                    let data = Bytes::copy_from_slice(&buf[..n]);
                    if stdin_tx.blocking_send(data).is_err() {
                        break;
                    }
                }
                Err(e) => {
                    tracing::error!(?e, "stdin read error");
                    break;
                }
            }
        }
    });

    // Axum server
    let app = api::router();
    let addr: SocketAddr = "127.0.0.1:8080".parse()?;
    tracing::info!(%addr, "API server listening");

    let server_handle = tokio::spawn(async move {
        let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
        axum::serve(listener, app).await.unwrap();
    });

    // Wait for PTY reader to finish (shell exited)
    pty_reader_handle.await?;

    drop(input_tx);
    let _ = pty_writer_handle.await;
    stdin_handle.abort();
    server_handle.abort();

    tracing::info!("wsh exiting");
    Ok(())
}
```

**Step 4: Test health endpoint**

In one terminal: `nix develop -c sh -c "cargo run"`
In another terminal: `curl http://localhost:8080/health`
Expected: `{"status":"ok"}`

**Step 5: Commit**

```bash
git add Cargo.toml src/api.rs src/main.rs
git commit -m "feat: add Axum server with /health endpoint"
```

---

## Task 7: POST /input Endpoint

**Files:**
- Modify: `src/api.rs`
- Modify: `src/main.rs`

**Step 1: Update api.rs with /input endpoint**

```rust
use axum::{
    extract::State,
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use bytes::Bytes;
use serde::Serialize;
use tokio::sync::mpsc;

#[derive(Clone)]
pub struct AppState {
    pub input_tx: mpsc::Sender<Bytes>,
}

#[derive(Serialize)]
struct HealthResponse {
    status: &'static str,
}

async fn health() -> Json<HealthResponse> {
    Json(HealthResponse { status: "ok" })
}

async fn input(State(state): State<AppState>, body: Bytes) -> StatusCode {
    match state.input_tx.send(body).await {
        Ok(_) => StatusCode::NO_CONTENT,
        Err(_) => StatusCode::BAD_REQUEST,
    }
}

pub fn router(state: AppState) -> Router {
    Router::new()
        .route("/health", get(health))
        .route("/input", post(input))
        .with_state(state)
}
```

**Step 2: Update main.rs to pass state to router**

Replace the Axum server section:

```rust
    // Axum server
    let state = api::AppState {
        input_tx: input_tx.clone(),
    };
    let app = api::router(state);
    let addr: SocketAddr = "127.0.0.1:8080".parse()?;
    tracing::info!(%addr, "API server listening");

    let server_handle = tokio::spawn(async move {
        let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
        axum::serve(listener, app).await.unwrap();
    });
```

**Step 3: Test /input endpoint**

In one terminal: `nix develop -c sh -c "cargo run"`
In another terminal: `curl -X POST -d 'echo hello' http://localhost:8080/input && curl -X POST -d $'\n' http://localhost:8080/input`
Expected: See "echo hello" typed and "hello" output in the wsh terminal

**Step 4: Commit**

```bash
git add src/api.rs src/main.rs
git commit -m "feat: add POST /input endpoint to send keystrokes to PTY"
```

---

## Task 8: WebSocket /ws/raw Endpoint

**Files:**
- Modify: `src/api.rs`
- Modify: `src/main.rs`

**Step 1: Update api.rs with WebSocket handler**

```rust
use axum::{
    extract::{
        ws::{Message, WebSocket, WebSocketUpgrade},
        State,
    },
    http::StatusCode,
    response::IntoResponse,
    routing::{get, post},
    Json, Router,
};
use bytes::Bytes;
use futures::{SinkExt, StreamExt};
use serde::Serialize;
use tokio::sync::{broadcast, mpsc};

#[derive(Clone)]
pub struct AppState {
    pub input_tx: mpsc::Sender<Bytes>,
    pub output_rx: broadcast::Sender<Bytes>,
}

#[derive(Serialize)]
struct HealthResponse {
    status: &'static str,
}

async fn health() -> Json<HealthResponse> {
    Json(HealthResponse { status: "ok" })
}

async fn input(State(state): State<AppState>, body: Bytes) -> StatusCode {
    match state.input_tx.send(body).await {
        Ok(_) => StatusCode::NO_CONTENT,
        Err(_) => StatusCode::BAD_REQUEST,
    }
}

async fn ws_raw(ws: WebSocketUpgrade, State(state): State<AppState>) -> impl IntoResponse {
    ws.on_upgrade(|socket| handle_ws_raw(socket, state))
}

async fn handle_ws_raw(socket: WebSocket, state: AppState) {
    let (mut ws_tx, mut ws_rx) = socket.split();

    let mut output_rx = state.output_rx.subscribe();
    let input_tx = state.input_tx.clone();

    // Task: broadcast PTY output -> WebSocket
    let tx_task = tokio::spawn(async move {
        while let Ok(data) = output_rx.recv().await {
            if ws_tx.send(Message::Binary(data.to_vec())).await.is_err() {
                break;
            }
        }
    });

    // Task: WebSocket input -> PTY
    let rx_task = tokio::spawn(async move {
        while let Some(Ok(msg)) = ws_rx.next().await {
            let data = match msg {
                Message::Binary(data) => Bytes::from(data),
                Message::Text(text) => Bytes::from(text),
                Message::Close(_) => break,
                _ => continue,
            };
            if input_tx.send(data).await.is_err() {
                break;
            }
        }
    });

    // Wait for either task to finish
    tokio::select! {
        _ = tx_task => {}
        _ = rx_task => {}
    }
}

pub fn router(state: AppState) -> Router {
    Router::new()
        .route("/health", get(health))
        .route("/input", post(input))
        .route("/ws/raw", get(ws_raw))
        .with_state(state)
}
```

**Step 2: Update broker.rs to expose sender**

```rust
use bytes::Bytes;
use tokio::sync::broadcast;

pub const BROADCAST_CAPACITY: usize = 64;

#[derive(Clone)]
pub struct Broker {
    tx: broadcast::Sender<Bytes>,
}

impl Broker {
    pub fn new() -> Self {
        let (tx, _) = broadcast::channel(BROADCAST_CAPACITY);
        Self { tx }
    }

    pub fn publish(&self, data: Bytes) {
        let _ = self.tx.send(data);
    }

    pub fn subscribe(&self) -> broadcast::Receiver<Bytes> {
        self.tx.subscribe()
    }

    pub fn sender(&self) -> broadcast::Sender<Bytes> {
        self.tx.clone()
    }
}
```

**Step 3: Update main.rs to pass broker sender to AppState**

Replace the Axum server section:

```rust
    // Axum server
    let state = api::AppState {
        input_tx: input_tx.clone(),
        output_rx: broker.sender(),
    };
    let app = api::router(state);
    let addr: SocketAddr = "127.0.0.1:8080".parse()?;
    tracing::info!(%addr, "API server listening");

    let server_handle = tokio::spawn(async move {
        let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
        axum::serve(listener, app).await.unwrap();
    });
```

**Step 4: Test WebSocket endpoint**

In one terminal: `nix develop -c sh -c "cargo run"`
In another terminal: `websocat ws://localhost:8080/ws/raw` (if websocat is available) or use browser console

Expected: See all PTY output streamed to the WebSocket client. Typing in websocat sends to PTY.

**Step 5: Commit**

```bash
git add src/api.rs src/broker.rs src/main.rs
git commit -m "feat: add WebSocket /ws/raw endpoint for real-time terminal streaming"
```

---

## Task 9: Signal Handling (Graceful Shutdown)

**Files:**
- Modify: `src/main.rs`

**Step 1: Add tokio signal handling**

Update Cargo.toml `tokio` features:
```toml
tokio = { version = "1", features = ["full", "signal"] }
```

**Step 2: Update main.rs with shutdown handling**

Add after the server_handle spawn:

```rust
    // Signal handling for graceful shutdown
    let shutdown = async {
        tokio::signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
        tracing::info!("Received Ctrl+C, shutting down");
    };

    tokio::select! {
        _ = pty_reader_handle => {
            tracing::info!("Shell exited");
        }
        _ = shutdown => {
            tracing::info!("Shutdown signal received");
        }
    }

    drop(input_tx);
    let _ = pty_writer_handle.await;
    stdin_handle.abort();
    server_handle.abort();

    tracing::info!("wsh exiting");
    Ok(())
```

Remove the earlier `pty_reader_handle.await?;` line since we're now using select.

**Step 3: Full main.rs after this task**

```rust
mod api;
mod broker;
mod pty;
mod terminal;

use bytes::Bytes;
use std::io::{Read, Write};
use std::net::SocketAddr;
use tokio::sync::mpsc;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "wsh=debug,tower_http=debug".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("wsh starting");

    let _raw_guard = terminal::RawModeGuard::new()?;

    let pty = pty::Pty::spawn()?;
    let mut pty_reader = pty.take_reader()?;
    let mut pty_writer = pty.take_writer()?;

    let broker = broker::Broker::new();
    let broker_clone = broker.clone();

    let (input_tx, mut input_rx) = mpsc::channel::<Bytes>(64);

    // PTY reader task
    let pty_reader_handle = tokio::task::spawn_blocking(move || {
        let mut stdout = std::io::stdout();
        let mut buf = [0u8; 4096];

        loop {
            match pty_reader.read(&mut buf) {
                Ok(0) => {
                    tracing::debug!("PTY reader: EOF");
                    break;
                }
                Ok(n) => {
                    let data = Bytes::copy_from_slice(&buf[..n]);
                    let _ = stdout.write_all(&data);
                    let _ = stdout.flush();
                    broker_clone.publish(data);
                }
                Err(e) => {
                    tracing::error!(?e, "PTY read error");
                    break;
                }
            }
        }
    });

    // PTY writer task
    let pty_writer_handle = tokio::task::spawn_blocking(move || {
        while let Some(data) = input_rx.blocking_recv() {
            if let Err(e) = pty_writer.write_all(&data) {
                tracing::error!(?e, "PTY write error");
                break;
            }
            let _ = pty_writer.flush();
        }
        tracing::debug!("PTY writer: channel closed");
    });

    // Stdin reader task
    let stdin_tx = input_tx.clone();
    let stdin_handle = tokio::task::spawn_blocking(move || {
        let mut stdin = std::io::stdin();
        let mut buf = [0u8; 1024];

        loop {
            match stdin.read(&mut buf) {
                Ok(0) => {
                    tracing::debug!("stdin: EOF");
                    break;
                }
                Ok(n) => {
                    let data = Bytes::copy_from_slice(&buf[..n]);
                    if stdin_tx.blocking_send(data).is_err() {
                        break;
                    }
                }
                Err(e) => {
                    tracing::error!(?e, "stdin read error");
                    break;
                }
            }
        }
    });

    // Axum server
    let state = api::AppState {
        input_tx: input_tx.clone(),
        output_rx: broker.sender(),
    };
    let app = api::router(state);
    let addr: SocketAddr = "127.0.0.1:8080".parse()?;
    tracing::info!(%addr, "API server listening");

    let server_handle = tokio::spawn(async move {
        let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
        axum::serve(listener, app).await.unwrap();
    });

    // Signal handling for graceful shutdown
    let shutdown = async {
        tokio::signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
        tracing::info!("Received Ctrl+C, shutting down");
    };

    tokio::select! {
        _ = pty_reader_handle => {
            tracing::info!("Shell exited");
        }
        _ = shutdown => {
            tracing::info!("Shutdown signal received");
        }
    }

    drop(input_tx);
    let _ = pty_writer_handle.await;
    stdin_handle.abort();
    server_handle.abort();

    tracing::info!("wsh exiting");
    Ok(())
}
```

**Step 4: Test graceful shutdown**

Run: `nix develop -c sh -c "cargo run"`
- Type `exit` in shell -> should exit cleanly
- Press Ctrl+C in raw mode won't work (goes to shell), but killing the process externally should work

**Step 5: Commit**

```bash
git add Cargo.toml src/main.rs
git commit -m "feat: add signal handling for graceful shutdown"
```

---

## Task 10: Terminal Resize (SIGWINCH)

**Files:**
- Modify: `src/terminal.rs`
- Modify: `src/main.rs`
- Modify: `src/pty.rs`

**Step 1: Add terminal size function to terminal.rs**

```rust
use crossterm::terminal::{disable_raw_mode, enable_raw_mode, size};

pub struct RawModeGuard {
    _private: (),
}

impl RawModeGuard {
    pub fn new() -> anyhow::Result<Self> {
        enable_raw_mode()?;
        Ok(Self { _private: () })
    }
}

impl Drop for RawModeGuard {
    fn drop(&mut self) {
        let _ = disable_raw_mode();
    }
}

pub fn terminal_size() -> anyhow::Result<(u16, u16)> {
    let (cols, rows) = size()?;
    Ok((rows, cols))
}
```

**Step 2: Update pty.rs to get initial size from terminal**

Update the `spawn` function:

```rust
use portable_pty::{native_pty_system, CommandBuilder, PtyPair, PtySize};
use std::io::{Read, Write};
use std::sync::Arc;

pub struct Pty {
    pair: PtyPair,
    child: Box<dyn portable_pty::Child + Send + Sync>,
}

impl Pty {
    pub fn spawn(rows: u16, cols: u16) -> anyhow::Result<Self> {
        let pty_system = native_pty_system();

        let size = PtySize {
            rows,
            cols,
            pixel_width: 0,
            pixel_height: 0,
        };

        let pair = pty_system.openpty(size)?;

        let shell = std::env::var("SHELL").unwrap_or_else(|_| "/bin/sh".to_string());
        let mut cmd = CommandBuilder::new(&shell);
        cmd.env("TERM", std::env::var("TERM").unwrap_or_else(|_| "xterm-256color".to_string()));

        let child = pair.slave.spawn_command(cmd)?;

        Ok(Self { pair, child })
    }

    pub fn take_reader(&self) -> anyhow::Result<Box<dyn Read + Send>> {
        Ok(self.pair.master.try_clone_reader()?)
    }

    pub fn take_writer(&self) -> anyhow::Result<Box<dyn Write + Send>> {
        Ok(self.pair.master.take_writer()?)
    }

    pub fn resize(&self, rows: u16, cols: u16) -> anyhow::Result<()> {
        self.pair.master.resize(PtySize {
            rows,
            cols,
            pixel_width: 0,
            pixel_height: 0,
        })?;
        Ok(())
    }

    pub fn wait(&mut self) -> anyhow::Result<portable_pty::ExitStatus> {
        Ok(self.child.wait()?)
    }
}
```

**Step 3: Update main.rs to use terminal size and handle SIGWINCH**

Add near the top of main(), after raw mode guard:

```rust
    let (rows, cols) = terminal::terminal_size().unwrap_or((24, 80));
    let pty = pty::Pty::spawn(rows, cols)?;
```

Add SIGWINCH handling (Linux/Unix only). After the server_handle spawn:

```rust
    // SIGWINCH handling for terminal resize
    #[cfg(unix)]
    let pty_for_resize = {
        // We need a way to resize from the signal handler
        // Since Pty isn't Send+Sync friendly for this, we'll use a channel
        let (resize_tx, mut resize_rx) = mpsc::channel::<(u16, u16)>(4);

        tokio::spawn(async move {
            let mut signal = tokio::signal::unix::signal(
                tokio::signal::unix::SignalKind::window_change(),
            )
            .expect("failed to install SIGWINCH handler");

            while signal.recv().await.is_some() {
                if let Ok((rows, cols)) = terminal::terminal_size() {
                    let _ = resize_tx.send((rows, cols)).await;
                }
            }
        });

        resize_rx
    };
```

Note: Full SIGWINCH support requires restructuring to share the PTY resize capability. For the PoC, we'll add a simpler approach - resize on startup only. Full SIGWINCH can be deferred to a follow-up.

**Step 4: Simplified version - just use terminal size at startup**

The full SIGWINCH handling requires sharing the PTY across tasks which adds complexity. For PoC, terminal size at startup is sufficient:

```rust
    let (rows, cols) = terminal::terminal_size().unwrap_or((24, 80));
    tracing::info!(rows, cols, "Terminal size");
    let pty = pty::Pty::spawn(rows, cols)?;
```

**Step 5: Test terminal size is picked up**

Run: `nix develop -c sh -c "cargo run"`
In the shell, run: `stty size` or `tput lines; tput cols`
Expected: Should show correct terminal dimensions

**Step 6: Commit**

```bash
git add src/terminal.rs src/pty.rs src/main.rs
git commit -m "feat: use actual terminal size when spawning PTY"
```

---

## Task 11: Final Integration Test

**Files:** None (manual testing)

**Step 1: Full integration test**

1. In terminal 1: `nix develop -c sh -c "cargo run"`
2. Verify: Shell prompt appears, interactive commands work
3. In terminal 2: `curl http://localhost:8080/health`
4. Expected: `{"status":"ok"}`
5. In terminal 2: `curl -X POST -d 'echo "hello from curl"' http://localhost:8080/input && curl -X POST -d $'\n' http://localhost:8080/input`
6. Expected: See command typed and output in terminal 1
7. In terminal 2: `websocat ws://localhost:8080/ws/raw` (or equivalent)
8. Expected: See terminal output stream, can type to send input
9. In terminal 1: Type `exit`
10. Expected: Clean shutdown, all tasks exit

**Step 2: Document any issues found**

If any issues, create follow-up tasks.

**Step 3: Final commit with any fixes**

```bash
git add -A
git commit -m "chore: Phase 1 PoC complete"
```

---

## Summary

Phase 1 delivers:
- PTY spawning with portable-pty
- Local stdin/stdout passthrough in raw mode
- Axum server on 127.0.0.1:8080
- `GET /health` - liveness check
- `POST /input` - send keystrokes to PTY
- `GET /ws/raw` - WebSocket streaming of PTY output + input
- Graceful shutdown on shell exit
- Terminal size detection at startup

**Not included (deferred to Phase 2+):**
- SIGWINCH resize propagation (requires restructuring)
- Terminal parsing/state machine
- Authentication
- Configurable bind address
